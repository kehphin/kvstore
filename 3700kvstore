#!/usr/bin/env python

import sys, socket, select, time, json, random, math

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# gives the current time in milliseconds since epoch
def getTimestamp():
  return int(time.time() * 1000)

# global vars
QUORUM = math.floor(((len(replica_ids) + 1) / 2 ) + 1)

LEADER_TIMEOUT = 1000 # 1 second
LAST_LEADER_TIMESTAMP = getTimestamp() 
IS_TIMEDOUT_FROM_LEADER = False
LAST_ELECTION_TIMESTAMP = 0
ELECTION_DURATION = 500
LEADER_VOTES = 0
CURRENT_TERM_VOTE = None
STATE = 'Follower'
RANDOM_ELECTION_WAIT_ENDING = None
LEADER_HEARTBEAT_RATE = 100
LAST_SENT_HEARTBEAT = 0

# append rpc vars
TERM = 0
LOG = ['empty'] # stores all msgs from client, with an offset throwaway
								# value so LOGs are 1-indexed
DATA = {} # should be the same across all replicas
COMMIT_INDEX = 0
LOG_INDEX = 0
LEADER_ID = None
LAST_APPLIED = 0

# leader vars
NEXT_INDEX = {} # ID to next log entry index
MATCH_INDEX = {} # ID to known log entry index replicated
QUORUM_COUNTER = {} # dict of messages to the votes they have



def checkLastLeaderTimestamp():
	global IS_TIMEDOUT_FROM_LEADER
	global RANDOM_ELECTION_WAIT_ENDING 
	global STATE
	global CURRENT_TERM_VOTE

	if (getTimestamp() - LAST_LEADER_TIMESTAMP > LEADER_TIMEOUT and STATE != 'Leader'):
		IS_TIMEDOUT_FROM_LEADER = True
		STATE = 'Candidate'

		if (getTimestamp() - LAST_ELECTION_TIMESTAMP > ELECTION_DURATION):
			if (RANDOM_ELECTION_WAIT_ENDING == None): #We are eligible to hold new election, start random timeout
				RANDOM_ELECTION_WAIT_ENDING = getTimestamp() + random.randint(100, 300)
				CURRENT_TERM_VOTE = None
			elif (getTimestamp() > RANDOM_ELECTION_WAIT_ENDING and CURRENT_TERM_VOTE == None):
				startElection()


def startElection():
	global TERM
	global LAST_ELECTION_TIMESTAMP
	global RANDOM_ELECTION_WAIT_ENDING 
	global LEADER_VOTES
	global CURRENT_TERM_VOTE

	TERM = TERM + 1
	LEADER_VOTES = 1
	CURRENT_TERM_VOTE = my_id
	RANDOM_ELECTION_WAIT_ENDING = None
	LAST_ELECTION_TIMESTAMP = getTimestamp()

	for replica in replica_ids:
		sock.send(json.dumps({'src': my_id, 'dst': replica, 'leader': my_id,
				                  'type': 'elect'}) + '\n')

def handleElectionMsg(msg):
	global CURRENT_TERM_VOTE
	if (IS_TIMEDOUT_FROM_LEADER and CURRENT_TERM_VOTE == None):
		CURRENT_TERM_VOTE = msg['src']
		sock.send(json.dumps({'src': my_id, 'dst': msg['src'], 'leader': msg['src'],
				                  'type': 'vote'}) + '\n')

def handleVoteMsg(msg):
	global LEADER_VOTES
	global STATE
	global IS_TIMEDOUT_FROM_LEADER
	global NEXT_INDEX

	LEADER_VOTES = LEADER_VOTES + 1

	if (LEADER_VOTES >= QUORUM):
		IS_TIMEDOUT_FROM_LEADER = False
		STATE = 'Leader'
		# initialize NEXT_INDEX log to its LAST_APPLIED
		for replica in replica_ids:
			NEXT_INDEX[replica] = LAST_APPLIED + 1

		sendAppend()
		print 'we are the new leader! ' + my_id

def handleAppendMsg(msg):
	global LEADER_ID
	global LOG
	global LAST_APPLIED
	global COMMIT_INDEX

	STATE = 'Follower'
	LEADER_ID = msg['leader']
	LAST_LEADER_TIMESTAMP = getTimestamp()

	leaderCommitIndex = msg['data']['commitIndex']

	for i in range(COMMIT_INDEX + 1, leaderCommitIndex + 1):
		commitPut(i)


	# empty append message means that its a heartbeat appendrpc
	if (len(msg['data']['entries']) == 0):
		if (msg['data']['nextIndex'] == LAST_APPLIED + 1):
			# we good
			sock.send(json.dumps({'src': my_id, 
														'dst': msg['src'], 
														'leader': msg['src'],
					                  'type': 'appendResponse', 
					                  'data': {
					                  	'status': 'ok',
					                  	'currLastApplied': LAST_APPLIED
					                  }}) + '\n')
		else:
			# send back rejection message to decrement next rpc by 1
			sock.send(json.dumps({'src': my_id, 
														'dst': msg['src'], 
														'leader': msg['src'],
					                  'type': 'appendResponse', 
					                  'data': {
					                  	'status': 'fail',
					                  	'currLastApplied': LAST_APPLIED
					                  }}) + '\n')

	else:
		# entries is greater than 0, meaning its a put appendrpc
		nextIndex = msg['data']['nextIndex']

		# append all entries to LOG, clobbering any unresponded entries if necessary
		for message in msg['data']['entries']:
			if (nextIndex >= len(LOG)):
				LOG.append(message)
				LAST_APPLIED = LAST_APPLIED + 1
			else:
				LOG[nextIndex] = msg
			nextIndex = nextIndex + 1

		sock.send(json.dumps({'src': my_id, 
													'dst': msg['src'], 
													'leader': msg['src'],
				                  'type': 'appendResponse', 
				                  'data': {
				                  	'status': 'ok',
				                  	'currLastApplied': LAST_APPLIED
				                  }}) + '\n')

# in the leader
def handleAppendResponseMsg(msg):
	global NEXT_INDEX
	global QUORUM_COUNTER

	# if failed, we resend with the last known successful log index from resp
	if (msg['data']['status'] == 'fail'):
		NEXT_INDEX[msg['src']] == msg['data']['currLastApplied'] + 1

		sock.send(json.dumps({'src': my_id, 
													'dst': replica, 
													'leader': my_id,
				                  'type': 'append', 
				                  'data': {
				                  	'nextIndex': NEXT_INDEX[[msg['src']]]
				                  }}) + '\n')

	else:
		# we good

		followerLastApplied = msg['data']['currLastApplied'] + 1
		print 'Replica ' + msg['src'] + ' has agreed with nextIndex of ' + `followerLastApplied`

		print '===== ' + `NEXT_INDEX[msg['src']]` + ' ==== ' + `msg['data']['currLastApplied']`

		# for loop is upper bound exclusive
		for i in range(NEXT_INDEX[msg['src']], msg['data']['currLastApplied'] + 1):
			print '===========reached leader handle apprend response============'

			QUORUM_COUNTER[i] = QUORUM_COUNTER[i] + 1

			if QUORUM_COUNTER[i] == QUORUM:
				commitPut(i)
				

		NEXT_INDEX[msg['src']] = followerLastApplied


def commitPut(msgId):
	global DATA
	global COMMIT_INDEX

	messageFromClient = LOG[msgId]
	# data is committed
	DATA[messageFromClient['key']] = messageFromClient['value']

	print 'committing message: ' + `msgId`

	COMMIT_INDEX = COMMIT_INDEX + 1

	if STATE is 'Leader':

		# tell the client that the put has successfully been stored and replicated
		sock.send(json.dumps({'src': my_id, 
													'dst': messageFromClient['src'], 
													'leader': my_id,
				                  'type': 'ok', 
				                  'MID': messageFromClient['MID']
				                  }) + '\n')

	
# assumes that the leader has received the get
def handleClientGet(msg):
	entry = ''

	if msg['key'] in DATA:
		entry = DATA[msg['key']]

	sock.send(json.dumps({'src': my_id, 
												'dst': msg['src'], 
												'leader': my_id,
			                  'type': 'ok', 
			                  'MID': msg['MID'],
			                  'value': entry
			                  }) + '\n')

# assumes that the leader has received the put
def handleClientPut(msg):
	global LOG
	global LAST_APPLIED
	global QUORUM_COUNTER

	#DATA[msg['key']] = msg['value']
	LOG.append(msg)
	LAST_APPLIED = LAST_APPLIED + 1

	# put msg in quorum counter, give one vote for ourselves
	QUORUM_COUNTER[LAST_APPLIED] = 1

	# send put to all other replicas and wait for quorum
	sendAppend()


def sendAppend():	
	global LAST_SENT_HEARTBEAT

	LAST_SENT_HEARTBEAT = getTimestamp()

	for replica in replica_ids:
		sock.send(json.dumps({'src': my_id, 
													'dst': replica, 
													'leader': my_id,
				                  'type': 'append', 
				                  'data': {
				                  	'nextIndex': NEXT_INDEX[replica],
				                  	'entries': LOG[NEXT_INDEX[replica]:],
				                  	'commitIndex': COMMIT_INDEX
				                  }}) + '\n')

		print 'Sending ' + `LOG[NEXT_INDEX[replica]:]` + ' from leader ' + my_id + ' to replica ' + replica 

def sendRedirectMsg(msg):
	sock.send(json.dumps({'src': my_id,
												'dst': msg['src'], 
												'leader': LEADER_ID,
				                'type': 'redirect', 
				                'MID': msg['MID']}) + '\n')

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
sock.connect(my_id)

last = 0

while True:
	# Blocks every 0.1 sec
	ready = select.select([sock], [], [], 0.1)[0]

	# Check to see if we have timed out from the leader
	checkLastLeaderTimestamp()

	if sock in ready:
		raw = sock.recv(32768)
		
		# we may receive multiple messages during a single recv(); \n denotes the break between messages
		for msg_raw in raw.split('\n'):
			if len(msg_raw) == 0: continue
			msg = json.loads(msg_raw)
			# {u'src': u'001C', u'dst': u'0004', u'MID': u'RUOGHAVY5WKOBT4Z', 
			# u'value': u'cf52a3ceb2de663d19b5516bda582426', u'key': u'VS45EDCU5XSDO3I1MGWQASAW7P31SRJA', 
			# u'type': u'put', u'leader': u'FFFF'}


			print `my_id` + ': ' + `DATA`

			if msg['type'] in ['get', 'put'] and STATE is not 'Leader':
				sendRedirectMsg(msg)

			else:
				# handle a client get request
				if msg['type'] == 'get':
					handleClientGet(msg)

				# handle a client put request
				if msg['type'] == 'put':
					handleClientPut(msg)

				# new election process
				if msg['type'] == 'elect':
					handleElectionMsg(msg)

				# appendRPC message
				if msg['type'] == 'append':
					print 'Received append at ' + my_id + ' from ' + msg['src']
					handleAppendMsg(msg)

				# appendRPC Response to leader
				if msg['type'] == 'appendResponse':
					print 'Received appendResponse at ' + my_id + ' from ' + msg['src']
					handleAppendResponseMsg(msg)

				# handle vote
				if msg['type'] == 'vote':
					handleVoteMsg(msg)
		
	# send heartbeat after every LEADER_HEARTBEAT_RATE
	if STATE == 'Leader' and getTimestamp() - LEADER_HEARTBEAT_RATE > LAST_SENT_HEARTBEAT:
		print 'about to send heartbeat'
		sendAppend()

