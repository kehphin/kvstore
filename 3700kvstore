#!/usr/bin/env python

import sys, socket, select, time, json, random, math

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# gives the current time in milliseconds since epoch
def getTimestamp():
  return int(time.time() * 1000)

# global vars
QUORUM = math.floor(((len(replica_ids) + 1) / 2 ) + 1)

ELECTION_TIMEOUT = 0 # If timeout expires, we must start an election
ELECTION_DURATION = 500 # Milliseconds to wait before starting election
LEADER_VOTES = [] # Array of all of the replicas that have voted for us this term
CURRENT_TERM_VOTE = None #ID of replica that we have voted for this term
STATE = 'Follower' #One of: Follower, Leader, Candidate
RANDOM_ELECTION_WAIT_ENDING = None #If our election failed, use this to start a random timeout before starting another
LEADER_HEARTBEAT_RATE = 20 # How often a leader should send a heartbeat append message
LAST_SENT_HEARTBEAT = 0 # When we last sent a heartbeat message 
REPLICA_TIMEOUT_LENGTH = 1500 #After how long we should time out a replica if we havent heard from it
NEXT_VOTE_FOR_ID = None
NEXT_VOTE_COMMIT_INDEX = None
IS_TIMED_OUT_FROM_LEADER = False
LAST_LEADER = None #Id of the last leader that has gone offline
TERM_DURING_LAST_LEADER = 0 #Term we were in when we had that last leader

# append rpc vars
TERM = 0
LOG = ['empty'] # stores all msgs from client, with an offset throwaway
								# value so LOGs are 1-indexed
DATA = {} # should be the same across all replicas
COMMIT_INDEX = 0 # index in the log of the last message that we have commited
LEADER_ID = None # ID of the replica that is the leader
LAST_APPLIED = 0 # index of the most recent element added to the log

# leader vars
NEXT_INDEX = {} # ID to next log entry index
MATCH_INDEX = {} # ID to known log entry index replicated
QUORUM_COUNTER = {} # dict of messages to the votes they have
IN_BETWEEN_QUORUM_COUNTER = {}
REPLICA_TIMEOUT = {} #dict mapping replica ids to the timestamp when we last heard from them

MESSAGE_QUEUE = [] #queue of messages that we received when we had no leader


def checkLastLeaderTimestamp():
	global RANDOM_ELECTION_WAIT_ENDING 
	global STATE
	global CURRENT_TERM_VOTE
	global LEADER_ID
	global ELECTION_TIMEOUT
	global IS_TIMED_OUT_FROM_LEADER
	global LAST_LEADER
	global TERM_DURING_LAST_LEADER

	if (getTimestamp() - ELECTION_TIMEOUT > ELECTION_DURATION and STATE != 'Leader'): #either timed out from leader or election
		if (not IS_TIMED_OUT_FROM_LEADER): #just timed out for first time
			IS_TIMED_OUT_FROM_LEADER = True
			LAST_LEADER = LEADER_ID
			TERM_DURING_LAST_LEADER = TERM
		print "Our leader " + `LEADER_ID` + " has timed out " + `my_id`
		LEADER_ID = None
		if (STATE is 'Candidate'): #timed out from election
			#print 'first election didnt work, random timeout ' + `my_id`
			print 'I will vote for ' + `NEXT_VOTE_FOR_ID` + ' from ' + `my_id`

			if (NEXT_VOTE_FOR_ID == my_id): #I am supposed to be next leader
				if RANDOM_ELECTION_WAIT_ENDING == None:
					RANDOM_ELECTION_WAIT_ENDING = getTimestamp() + random.randrange(100, 300)
				elif (getTimestamp() > RANDOM_ELECTION_WAIT_ENDING):
					startElection()
			else: #I am not going to be leader, wait to hear elect message
				ELECTION_TIMEOUT = getTimestamp()
				CURRENT_TERM_VOTE = None

		elif (CURRENT_TERM_VOTE == None): #we timed out from leader, and havent yet voted for anyone
			STATE = 'Candidate'
			startElection()


def startElection():
	global TERM
	global ELECTION_TIMEOUT
	global RANDOM_ELECTION_WAIT_ENDING 
	global LEADER_VOTES
	global CURRENT_TERM_VOTE
	global NEXT_VOTE_FOR_ID
	global NEXT_VOTE_COMMIT_INDEX

	print 'starting election at ' + `my_id`
	ELECTION_TIMEOUT = getTimestamp()
	TERM = TERM + 1
	LEADER_VOTES= [my_id] #vote for yourself
	CURRENT_TERM_VOTE = my_id
	RANDOM_ELECTION_WAIT_ENDING = None

	NEXT_VOTE_FOR_ID = my_id
	NEXT_VOTE_COMMIT_INDEX = COMMIT_INDEX

	for replica in replica_ids:
		sendElectionMessageTo(replica)

def sendElectionMessageTo(dest):
	for i in range(0, 3):
		sock.send(json.dumps({'src': my_id, 'dst': dest, 'leader': my_id,
					                  'type': 'elect', 'data': {'lastCommmited' : COMMIT_INDEX, 'logLength': LAST_APPLIED}}) + '\n')

def handleElectionMsg(msg):
	global CURRENT_TERM_VOTE
	global NEXT_VOTE_FOR_ID
	global NEXT_VOTE_COMMIT_INDEX

	print 'heard election message ' + `msg`

	if (msg['data']['lastCommmited'] == NEXT_VOTE_COMMIT_INDEX):
		NEXT_VOTE_FOR_ID = max(NEXT_VOTE_FOR_ID, msg['src'])
	elif (msg['data']['lastCommmited'] > NEXT_VOTE_COMMIT_INDEX):
		NEXT_VOTE_FOR_ID = msg['src']
		NEXT_VOTE_COMMIT_INDEX = msg['data']['lastCommmited']


	if (CURRENT_TERM_VOTE == None or CURRENT_TERM_VOTE == msg['src']) and IS_TIMED_OUT_FROM_LEADER:
		if (msg['data']['lastCommmited'] >= COMMIT_INDEX):
			CURRENT_TERM_VOTE = msg['src']
			print 'voting for ' + msg['src'] + ' from ' + `my_id`
			voteFor(msg['src'])

def voteFor(dest):
	for i in range(0,3):
		sock.send(json.dumps({'src': my_id, 'dst': dest, 'leader': dest,
						                  'type': 'vote'}) + '\n')


def handleVoteMsg(msg):
	global LEADER_VOTES
	global STATE
	global NEXT_INDEX
	global LEADER_ID
	global TERM
	global IN_BETWEEN_QUORUM_COUNTER
	global replica_ids
	global LAST_LEADER

	if (STATE == 'Candidate'):
		if (msg['src'] not in LEADER_VOTES):	
			LEADER_VOTES.append(msg['src'])

		if (len(LEADER_VOTES) >= QUORUM):
			STATE = 'Leader'
			LEADER_ID = my_id
			print '===========================we are the new leader! ' + my_id + '==============================='

			#emptyMessageQueue()
			if LAST_LEADER in replica_ids:
				replica_ids.remove(LAST_LEADER)

			for replica in replica_ids:
				NEXT_INDEX[replica] = LAST_APPLIED + 1

			for replica in replica_ids:
				REPLICA_TIMEOUT[replica] = {'lastHeardFrom' : getTimestamp()}

			if (COMMIT_INDEX == LAST_APPLIED):
				IN_BETWEEN_QUORUM_COUNTER = None
			else:
				for i in range(COMMIT_INDEX + 1, LAST_APPLIED + 1):
					print "setting the quourm counter for " + `i` + " to be one at the new leader"
					QUORUM_COUNTER[i] = 1
					IN_BETWEEN_QUORUM_COUNTER[i] = [my_id]



			TERM = TERM + 1

			sendAppend()
			sendAppend()
			sendAppend()


def handleAppendMsg(msg):
	global LEADER_ID
	global LOG
	global LAST_APPLIED
	global COMMIT_INDEX
	global RANDOM_ELECTION_WAIT_ENDING
	global CURRENT_TERM_VOTE
	global TERM
	global ELECTION_TIMEOUT
	global STATE
	global MESSAGE_QUEUE
	global IS_TIMED_OUT_FROM_LEADER
	global LAST_LEADER

	
	if(LEADER_ID == None and msg['src'] == LAST_LEADER): #we wrongly timed out, undo eveything from election
		LAST_LEADER = None
		CURRENT_TERM_VOTE = None
		TERM = TERM_DURING_LAST_LEADER
		print "is it too late now to say soryyyyyyyyyyyyyyyyyyyyy"

	print "updating last election timestamp at " + `my_id`
	ELECTION_TIMEOUT = getTimestamp()
	STATE = 'Follower'
	LEADER_ID = msg['src']
	IS_TIMED_OUT_FROM_LEADER = False

	if(msg['data']['term'] > TERM):
		print 'Just heard from new leader, incrementing term ' + `my_id`
		TERM = msg['data']['term']
		CURRENT_TERM_VOTE = None
		RANDOM_ELECTION_WAIT_ENDING = None
		#emptyMessageQueue()


	leaderCommitIndex = msg['data']['commitIndex']

	# commit as many mesages as we can to match leader
	for i in range(COMMIT_INDEX + 1, min(leaderCommitIndex + 1, len(LOG))):
		commitPut(i)


	# empty append message means that its a heartbeat appendrpc
	if (len(msg['data']['entries']) == 0):
		if (msg['data']['nextIndex'] == LAST_APPLIED + 1):
			# we good
			data = {'status': 'ok', 'currLastApplied': LAST_APPLIED}
			sendMessageToReplica(msg['src'], 'appendResponse', data)
		else:
			# send back rejection message to decrement next rpc by 1
			data = {'status': 'fail', 'currLastApplied': LAST_APPLIED}
			sendMessageToReplica(msg['src'], 'appendResponse', data)

	else:
		# entries is greater than 0, meaning its a put appendrpc
		nextIndex = msg['data']['nextIndex']

		# append all entries to LOG, clobbering any unresponded entries if necessary
		for message in msg['data']['entries']:
			if (nextIndex >= len(LOG)):
				LOG.append(message)
				LAST_APPLIED = LAST_APPLIED + 1
			else:
				LOG[nextIndex] = message
			nextIndex = nextIndex + 1

		data = {'status': 'ok', 'currLastApplied': LAST_APPLIED}
		sendMessageToReplica(msg['src'], 'appendResponse', data)

# in the leader
def handleAppendResponseMsg(msg):
	global NEXT_INDEX
	global QUORUM_COUNTER
	global REPLICA_TIMEOUT
	global IN_BETWEEN_QUORUM_COUNTER
	global COMMIT_INDEX

	REPLICA_TIMEOUT[msg['src']]['lastHeardFrom'] = getTimestamp()

	# if failed, we resend with the last known successful log index from resp
	if (msg['data']['status'] == 'fail'):
		NEXT_INDEX[msg['src']] == msg['data']['currLastApplied'] + 1
		data = {'nextIndex': NEXT_INDEX[msg['src']],
				'entries': LOG[NEXT_INDEX[msg['src']]:],
				'commitIndex': COMMIT_INDEX,
				'term': TERM}

		sendMessageToReplica(msg['src'], 'append', data)

	else:
		# we good

		followerLastApplied = msg['data']['currLastApplied'] + 1

		
		if (IN_BETWEEN_QUORUM_COUNTER is not None):
			for key in IN_BETWEEN_QUORUM_COUNTER.keys():
				if (key < followerLastApplied and msg['src'] not in IN_BETWEEN_QUORUM_COUNTER[key]):
					IN_BETWEEN_QUORUM_COUNTER[key].append(msg['src'])
					QUORUM_COUNTER[key] = QUORUM_COUNTER[key] + 1
					if QUORUM_COUNTER[key] == QUORUM:
						commitPut(key)
						del IN_BETWEEN_QUORUM_COUNTER[key]
						if len(IN_BETWEEN_QUORUM_COUNTER) == 0:
							IN_BETWEEN_QUORUM_COUNTER = None
							print 'killing dah bitch!!!!!!!!!!!!!!!!'
		

		# for loop is upper bound exclusive
		for i in range(NEXT_INDEX[msg['src']], followerLastApplied):
			if (i > COMMIT_INDEX): #only would have it if we had commited message, leader died, we became leader, and then another replica put it in their logs, in which case it has already beem commited and can be ignored
				print i
				QUORUM_COUNTER[i] = QUORUM_COUNTER[i] + 1

				if QUORUM_COUNTER[i] == QUORUM:
					commitPut(i)
			
		NEXT_INDEX[msg['src']] = followerLastApplied


def commitPut(msgId):
	global DATA
	global COMMIT_INDEX

	messageFromClient = LOG[msgId]
	# data is committed
	DATA[messageFromClient['key']] = messageFromClient['value']

	print 'committing message: ' + `msgId` + ' at ' + `my_id`

	COMMIT_INDEX = COMMIT_INDEX + 1

	if STATE is 'Leader':

		# tell the client that the put has successfully been stored and replicated
		sock.send(json.dumps({'src': my_id, 
								'dst': messageFromClient['src'], 
								'leader': my_id,
				                'type': 'ok', 
				                'MID': messageFromClient['MID']
				                  }) + '\n')

	
# assumes that the leader has received the get
def handleClientGet(msg):
	entry = ''

	if msg['key'] in DATA:
		entry = DATA[msg['key']]

	sock.send(json.dumps({'src': my_id, 
							'dst': msg['src'], 
							'leader': my_id,
			                'type': 'ok', 
			                'MID': msg['MID'],
			                'value': entry
			                  }) + '\n')

# assumes that the leader has received the put
def handleClientPut(msg):
	global LOG
	global LAST_APPLIED
	global QUORUM_COUNTER

	#DATA[msg['key']] = msg['value']
	LOG.append(msg)
	LAST_APPLIED = LAST_APPLIED + 1

	# put msg in quorum counter, give one vote for ourselves
	QUORUM_COUNTER[LAST_APPLIED] = 1

	print "adding " + `LAST_APPLIED` + ' to quorum counter'

	# send put to all other replicas and wait for quorum
	sendAppend()


def sendAppend():	
	global LAST_SENT_HEARTBEAT
	global TERM

	LAST_SENT_HEARTBEAT = getTimestamp()

	for replica in replica_ids:
		data = {'nextIndex': NEXT_INDEX[replica],
				'entries': LOG[NEXT_INDEX[replica]:],
				'commitIndex': COMMIT_INDEX,
				'term': TERM}
		sendMessageToReplica(replica, 'append', data)

		#print 'Sending ' + `LOG[NEXT_INDEX[replica]:]` + ' from leader ' + my_id + ' to replica ' + replica 

def sendRedirectMsg(msg):
	global LEADER_ID

	sock.send(json.dumps({'src': my_id,
								'dst': msg['src'], 
								'leader': LEADER_ID,
				                'type': 'redirect', 
				                'MID': msg['MID']}) + '\n')

def checkReplicaTimeouts():
	global replica_ids
	global REPLICA_TIMEOUT

	for replica in replica_ids:
		if REPLICA_TIMEOUT[replica]['lastHeardFrom'] + REPLICA_TIMEOUT_LENGTH < getTimestamp():
			print `replica` + ' has gone offline ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
			replica_ids.remove(replica)



def sendMessageToReplica(dest, msgType, data):
	sock.send(json.dumps({'src': my_id, 
							'dst': dest, 
							'leader': LEADER_ID,
				            'type': msgType, 
				            'data': data
				         }) + '\n')

def sendFailMsg(msg):
	global LEADER_ID

	sock.send(json.dumps({'src': my_id,
								'dst': msg['src'], 
								'leader': LEADER_ID,
				                'type': 'fail', 
				                'MID': msg['MID']}) + '\n')

def emptyMessageQueue():
	global MESSAGE_QUEUE

	for queuedMsg in MESSAGE_QUEUE:
		print queuedMsg
		sendFailMsg(queuedMsg)
	MESSAGE_QUEUE = []


# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
sock.connect(my_id)

last = 0

while True:
	# Blocks every 0.1 sec
	ready = select.select([sock], [], [], 0.1)[0]

	# Check to see if we have timed out from the leader
	checkLastLeaderTimestamp()

	print `CURRENT_TERM_VOTE` +  ' ' + `my_id`

	if STATE is 'Leader':
		checkReplicaTimeouts()

	if sock in ready:
		raw = sock.recv(32768)
		
		# we may receive multiple messages during a single recv(); \n denotes the break between messages
		for msg_raw in raw.split('\n'):
			if len(msg_raw) == 0: continue
			msg = json.loads(msg_raw)
			# {u'src': u'001C', u'dst': u'0004', u'MID': u'RUOGHAVY5WKOBT4Z', 
			# u'value': u'cf52a3ceb2de663d19b5516bda582426', u'key': u'VS45EDCU5XSDO3I1MGWQASAW7P31SRJA', 
			# u'type': u'put', u'leader': u'FFFF'}

			if msg['type'] in ['get', 'put'] and LEADER_ID == None:
				MESSAGE_QUEUE.append(msg)

			elif msg['type'] in ['get', 'put'] and STATE is not 'Leader':
				sendRedirectMsg(msg)

			else:
				# handle a client get request
				if msg['type'] == 'get':
					handleClientGet(msg)

				# handle a client put request
				if msg['type'] == 'put':
					handleClientPut(msg)

				# new election process
				if msg['type'] == 'elect':
					handleElectionMsg(msg)

				# appendRPC message
				if msg['type'] == 'append':
					print 'Received append at ' + my_id + ' from ' + msg['src']
					handleAppendMsg(msg)

				# appendRPC Response to leader
				if msg['type'] == 'appendResponse':
					print 'Received appendResponse at ' + my_id + ' from ' + msg['src']
					handleAppendResponseMsg(msg)

				# handle vote
				if msg['type'] == 'vote':
					handleVoteMsg(msg)
		
	# send heartbeat after every LEADER_HEARTBEAT_RATE
	if STATE == 'Leader' and getTimestamp() - LEADER_HEARTBEAT_RATE > LAST_SENT_HEARTBEAT:
	#if STATE == 'Leader':
		print 'about to send heartbeat'
		sendAppend()

